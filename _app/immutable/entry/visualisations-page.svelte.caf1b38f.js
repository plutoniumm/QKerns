import{S as fe,i as pe,s as W,k as M,l as P,m as I,h as d,n as S,p as _e,b as j,K as z,o as de,w as ye,a as K,q as N,e as Y,D as ve,c as R,r as C,E as ee,F as x,g as B,f as G,d as T,J as L,u as Q,v as U,Z as te,O as ge,y as be,z as we,A as Fe,B as xe}from"../chunks/index.997ad408.js";import{_ as $e}from"../chunks/preload-helper.41c905a7.js";const ae=(a=0,t=1)=>Math.random()*(t-a)+a,le=(a,t,l)=>{const e=new Float32Array(l),c=(t-a)/(l-1);for(let n=0;n<l;n++)e[n]=a+c*n;return e},ke=(a,t="scatter3d")=>{let l,e,c;return t==="scatter3d"&&(l=new Float32Array(a),e=new Float32Array(a),c=new Float32Array(a)),t==="heatmap"&&(l=le(-1,1,a),e=le(-1,1,a),c=new Array(a)),[l,e,c]},J=()=>Math.round(Math.random()*1e10).toString(36);function Ee(a){let t;return{c(){t=M("div"),this.h()},l(l){t=P(l,"DIV",{id:!0,class:!0,style:!0}),I(t).forEach(d),this.h()},h(){S(t,"id",a[1]),S(t,"class","w-100 fade-up h-100 plut svelte-185ij4c"),_e(t,"height","400px")},m(l,e){j(l,t,e),a[6](t)},p:z,i:z,o:z,d(l){l&&d(t),a[6](null)}}}function Me(a,t,l){let e;const c=J();let{F:n=(u,b)=>u*b}=t,{samples:r=1e3}=t,{name:o="Function"}=t,{type:v="scatter3d"}=t,[w,F,E]=ke(r,v);const h={heatmap:()=>{for(let u=0;u<r;u++)E[u]=new Float32Array(w.map(b=>n(b,F[u])))},scatter3d:()=>{for(let u=0;u<r;u++)w[u]=ae(-1,1),F[u]=ae(-1,1),E[u]=n(w[u],F[u])}};de(async()=>{const u=await $e(()=>import("../chunks/plotly.cba99116.js").then(f=>f.p),["../chunks/plotly.cba99116.js","../chunks/_commonjsHelpers.725317a4.js"],import.meta.url);for(let f=0;f<r;f++)h[v]();let b={x:w,y:F,z:E,type:v,mode:"markers",marker:{size:Math.floor(16/Math.round(Math.log10(r))),color:E,colorscale:"Viridis",opacity:.75},hoverongaps:!1};u.newPlot(c,[b],{title:`${o} ${v}`.toUpperCase(),margin:{l:20,r:20,b:50,t:50}})});function p(u){ye[u?"unshift":"push"](()=>{e=u,l(0,e)})}return a.$$set=u=>{"F"in u&&l(2,n=u.F),"samples"in u&&l(3,r=u.samples),"name"in u&&l(4,o=u.name),"type"in u&&l(5,v=u.type)},[e,c,n,r,o,v,p]}class Pe extends fe{constructor(t){super(),pe(this,t,Me,Ee,W,{F:2,samples:3,name:4,type:5})}}function ne(a,t,l){const e=a.slice();e[12]=t[l],e[17]=l;const c=e[12].name;e[13]=c;const n=e[12].f;e[14]=n;const r=J();return e[15]=r,e}function re(a,t,l){const e=a.slice();return e[18]=t[l][0],e[19]=t[l][1],e}function se(a,t,l){const e=a.slice();e[22]=t[l],e[25]=t,e[26]=l;const c=J();e[23]=c;const n=e[22].name;return e[24]=n,e}function oe(a){let t,l=a[24]+"",e,c,n,r,o,v,w,F;function E(){a[11].call(o,a[25],a[26])}return{c(){t=M("label"),e=N(l),c=N(":"),r=K(),o=M("input"),this.h()},l(h){t=P(h,"LABEL",{class:!0,for:!0});var p=I(t);e=C(p,l),c=C(p,":"),p.forEach(d),r=R(h),o=P(h,"INPUT",{name:!0,class:!0,type:!0}),this.h()},h(){S(t,"class","fw5 svelte-32rhl6"),S(t,"for",n=a[24]+"-"+a[15]),S(o,"name",v=a[24]+"-"+a[23]),S(o,"class","rpm-5 svelte-32rhl6"),S(o,"type","text")},m(h,p){j(h,t,p),x(t,e),x(t,c),j(h,r,p),j(h,o,p),te(o,a[22].value),w||(F=ge(o,"input",E),w=!0)},p(h,p){a=h,p&1&&l!==(l=a[24]+"")&&Q(e,l),p&1&&n!==(n=a[24]+"-"+a[15])&&S(t,"for",n),p&1&&v!==(v=a[24]+"-"+a[23])&&S(o,"name",v),p&1&&o.value!==a[22].value&&te(o,a[22].value)},d(h){h&&d(t),h&&d(r),h&&d(o),w=!1,F()}}}function ie(a){let t,l;return t=new Pe({props:{samples:a[19],type:a[18],name:a[13],F:new Function("x","y",...a[12].params.map(me),a[14])}}),{c(){be(t.$$.fragment)},l(e){we(t.$$.fragment,e)},m(e,c){Fe(t,e,c),l=!0},p(e,c){const n={};c&1&&(n.name=e[13]),c&1&&(n.F=new Function("x","y",...e[12].params.map(me),e[14])),t.$set(n)},i(e){l||(B(t.$$.fragment,e),l=!0)},o(e){T(t.$$.fragment,e),l=!1},d(e){xe(t,e)}}}function ce(a){let t,l=a[12].params.map(he).join("-"),e,c,n=ie(a);return{c(){t=M("div"),n.c(),e=K(),this.h()},l(r){t=P(r,"DIV",{class:!0});var o=I(t);n.l(o),e=R(o),o.forEach(d),this.h()},h(){S(t,"class","w-100")},m(r,o){j(r,t,o),n.m(t,null),x(t,e),c=!0},p(r,o){o&1&&W(l,l=r[12].params.map(he).join("-"))?(U(),T(n,1,1,z),G(),n=ie(r),n.c(),B(n,1),n.m(t,e)):n.p(r,o)},i(r){c||(B(n),c=!0)},o(r){T(n),c=!1},d(r){r&&d(t),n.d(r)}}}function ue(a){let t,l,e,c,n=a[12].title+"",r,o,v,w=a[12].desc+"",F,E,h,p,u,b,f,H,m,y,_=a[12].params,$=[];for(let s=0;s<_.length;s+=1)$[s]=oe(se(a,_,s));let D=[["scatter3d",1e3],["heatmap",50]],k=[];for(let s=0;s<2;s+=1)k[s]=ce(re(a,D,s));const O=s=>T(k[s],1,1,()=>{k[s]=null});return{c(){t=M("hr"),l=K(),e=M("section"),c=M("h2"),r=N(n),o=K(),v=M("div"),F=N(w),E=K(),h=M("div"),p=M("br"),u=K(),b=M("div");for(let s=0;s<$.length;s+=1)$[s].c();f=K(),H=M("div");for(let s=0;s<2;s+=1)k[s].c();m=K(),this.h()},l(s){t=P(s,"HR",{class:!0}),l=R(s),e=P(s,"SECTION",{});var g=I(e);c=P(g,"H2",{});var i=I(c);r=C(i,n),i.forEach(d),o=R(g),v=P(g,"DIV",{});var A=I(v);F=C(A,w),A.forEach(d),E=R(g),h=P(g,"DIV",{});var q=I(h);p=P(q,"BR",{}),u=R(q),b=P(q,"DIV",{class:!0,style:!0});var Z=I(b);for(let V=0;V<$.length;V+=1)$[V].l(Z);Z.forEach(d),f=R(q),H=P(q,"DIV",{class:!0});var X=I(H);for(let V=0;V<2;V+=1)k[V].l(X);X.forEach(d),q.forEach(d),m=R(g),g.forEach(d),this.h()},h(){S(t,"class","o-25"),S(b,"class","params w-100 ƒ p5"),_e(b,"background","#ccc"),S(H,"class","ƒ")},m(s,g){j(s,t,g),j(s,l,g),j(s,e,g),x(e,c),x(c,r),x(e,o),x(e,v),x(v,F),x(e,E),x(e,h),x(h,p),x(h,u),x(h,b);for(let i=0;i<$.length;i+=1)$[i]&&$[i].m(b,null);x(h,f),x(h,H);for(let i=0;i<2;i+=1)k[i]&&k[i].m(H,null);x(e,m),y=!0},p(s,g){if((!y||g&1)&&n!==(n=s[12].title+"")&&Q(r,n),(!y||g&1)&&w!==(w=s[12].desc+"")&&Q(F,w),g&1){_=s[12].params;let i;for(i=0;i<_.length;i+=1){const A=se(s,_,i);$[i]?$[i].p(A,g):($[i]=oe(A),$[i].c(),$[i].m(b,null))}for(;i<$.length;i+=1)$[i].d(1);$.length=_.length}if(g&1){D=[["scatter3d",1e3],["heatmap",50]];let i;for(i=0;i<2;i+=1){const A=re(s,D,i);k[i]?(k[i].p(A,g),B(k[i],1)):(k[i]=ce(A),k[i].c(),B(k[i],1),k[i].m(H,null))}for(U(),i=2;i<2;i+=1)O(i);G()}},i(s){if(!y){for(let g=0;g<2;g+=1)B(k[g]);y=!0}},o(s){k=k.filter(Boolean);for(let g=0;g<2;g+=1)T(k[g]);y=!1},d(s){s&&d(t),s&&d(l),s&&d(e),L($,s),L(k,s)}}}function Se(a){let t,l,e,c,n,r,o,v,w,F,E,h,p,u,b=a[0],f=[];for(let m=0;m<b.length;m+=1)f[m]=ue(ne(a,b,m));const H=m=>T(f[m],1,1,()=>{f[m]=null});return{c(){t=M("script"),e=M("script"),n=K(),r=M("section"),o=M("h1"),v=N("Kernel Functions"),w=K(),F=M("div"),E=N(`The ultimate objective of a kernel is to use some fancy way to still tell us
    how similar any two inputs $x$, $x'$ are and map it to a higher dimensions.
    Some commonly used kernels are as follows. Our objective here is to define
    some basic kernels and then see how we can use them to combine them and
    generate fancier functions`),h=K();for(let m=0;m<f.length;m+=1)f[m].c();p=Y(),this.h()},l(m){const y=ve("svelte-1tfm19b",document.head);t=P(y,"SCRIPT",{src:!0});var _=I(t);_.forEach(d),e=P(y,"SCRIPT",{src:!0});var $=I(e);$.forEach(d),y.forEach(d),n=R(m),r=P(m,"SECTION",{});var D=I(r);o=P(D,"H1",{});var k=I(o);v=C(k,"Kernel Functions"),k.forEach(d),w=R(D),F=P(D,"DIV",{});var O=I(F);E=C(O,`The ultimate objective of a kernel is to use some fancy way to still tell us
    how similar any two inputs $x$, $x'$ are and map it to a higher dimensions.
    Some commonly used kernels are as follows. Our objective here is to define
    some basic kernels and then see how we can use them to combine them and
    generate fancier functions`),O.forEach(d),D.forEach(d),h=R(m);for(let s=0;s<f.length;s+=1)f[s].l(m);p=Y(),this.h()},h(){ee(t.src,l="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.5.1/math.js")||S(t,"src",l),ee(e.src,c="https://unpkg.com/bessel@1.0.2/bessel.js")||S(e,"src",c)},m(m,y){x(document.head,t),x(document.head,e),j(m,n,y),j(m,r,y),x(r,o),x(o,v),x(r,w),x(r,F),x(F,E),j(m,h,y);for(let _=0;_<f.length;_+=1)f[_]&&f[_].m(m,y);j(m,p,y),u=!0},p(m,[y]){if(y&1){b=m[0];let _;for(_=0;_<b.length;_+=1){const $=ne(m,b,_);f[_]?(f[_].p($,y),B(f[_],1)):(f[_]=ue($),f[_].c(),B(f[_],1),f[_].m(p.parentNode,p))}for(U(),_=b.length;_<f.length;_+=1)H(_);G()}},i(m){if(!u){for(let y=0;y<b.length;y+=1)B(f[y]);u=!0}},o(m){f=f.filter(Boolean);for(let y=0;y<f.length;y+=1)T(f[y]);u=!1},d(m){d(t),d(e),m&&d(n),m&&d(r),m&&d(h),L(f,m),m&&d(p)}}}const me=a=>`${a.name}=${a.value}`,he=a=>a.value;function Ie(a,t,l){let e,c,n,r,o,v,w,F,E,h,p;function u(b,f){b[f].value=this.value,l(0,p),l(10,e),l(9,c),l(8,n),l(7,r),l(6,o),l(5,v),l(4,w),l(3,F),l(2,E),l(1,h)}return a.$$.update=()=>{a.$$.dirty&2046&&l(0,p=[{name:"Plain",title:"Baseline testing with just to see things work",desc:`Here we plot the function $F(x, y) = x * y$ simply for an established
         baseline.`,params:[],f:"return x**2 * y**2;"},{name:"RBF",title:"RBF Kernel: $F(x, y) = e^{-\\gamma * (x - y)^2}$",params:[{name:"gamma",value:e}],desc:"Here we plot the function $F(x, y) = e^{-\\gamma * (x - y)^2}$, where $gamma$ is a hyperparameter.",f:"return Math.exp(-1 * gamma * (x - y) ** 2);"},{name:"Sigmoid",title:"Sigmoid Kernel: $F(x, y) = \\tanh(\\gamma * (x - y) + \\beta)$",desc:"Here we plot the function $F(x, y) = \\tanh(\\gamma * (x - y) + \\beta)$, where $\\gamma$ and $\\beta=0.5$ are hyperparameters.",params:[{name:"gamma",value:c},{name:"beta",value:n}],f:"return Math.tanh(gamma * (x - y) + beta);"},{name:"Polynomial",title:"Polynomial Kernel: $F(x, y) = (\\gamma * (x - y) + \\beta)^d$",desc:"Here we plot the function $F(x, y) = (\\gamma * (x - y) + \\beta)^d$, where $\\gamma$, $\\beta=0.5$ and $d=2$ are hyperparameters.",params:[{name:"gamma",value:r},{name:"d",value:o},{name:"r",value:v}],f:"return (gamma * (x - y) + r) ** d;"},{name:"Matern",title:"Matern Kernel: $F(x, y) = \\frac{2^{1-\\nu}}{\\Gamma(\\nu)}\\left(\\sqrt{2\\nu}\\frac{|x - y|}{\\lambda}\\right)^\\nu K_\\nu\\left(\\sqrt{2\\nu}\\frac{|x - y|}{\\lambda}\\right)$",desc:"Here we plot the function $F(x, y) = \\frac{2^{1-\\nu}}{\\Gamma(\\nu)}\\left(\\sqrt{2\\nu}\\frac{|x - y|}{\\lambda}\\right)^\\nu K_\\nu\\left(\\sqrt{2\\nu}\\frac{|x - y|}{\\lambda}\\right)$, where $\\nu=1.5$ and $\\lambda=1$ are hyperparameters.",params:[{name:"nu",value:w}],f:`{
        return (
          (2 ** (1 - nu)) / math.gamma(nu) *
          ((2 * nu) ** 0.5 * Math.abs(x - y)) ** nu *
          BESSEL.besselk(nu, (2 * nu) ** 0.5 * Math.abs(x - y))
        );
      };`},{name:"Periodic or ESS",title:"Periodic Kernel: $F(x, y) = \\exp\\left(-\\frac{2\\sin^2\\left(\\pi\\frac{|x - y|}{p}\\right)}{l^2}\\right)$",desc:"Here we plot the function $F(x, y) = \\exp\\left(-\\frac{2\\sin^2\\left(\\pi\\frac{|x - y|}{p}\\right)}{l^2}\\right)$, where $l=1$ and $p=1$ are hyperparameters.",params:[],f:"return Math.exp(-2 * Math.sin(Math.PI * Math.abs(x - y)) ** 2);"},{name:"RQ",title:"RQ Kernel: $F(x, y) = \\left(1 + \\frac{|x - y|^2}{2\\alpha l^2}\\right)^{-\\alpha}$",desc:"Here we plot the function $F(x, y) = \\left(1 + \\frac{|x - y|^2}{2\\alpha l^2}\\right)^{-\\alpha}$, where $\\alpha=1$ and $l=1$ are hyperparameters.",params:[{name:"alpha",value:F},{name:"l",value:E}],f:"return (1 + (x - y) ** 2 / (2 * alpha * l ** 2)) ** -alpha;"},{name:"White Noise",title:"White Noise Kernel: $F(x, y) = v\\delta(x - y)$",desc:"Here we plot the function $F(x, y) = v\\delta(x - y)$, where $v=1$ is a hyperparameter.",params:[{name:"v",value:h}],f:"return v * (x === y ? 1 : 0);"}])},e=1,c=1,n=.5,r=1,o=2,v=.5,w=1.5,F=1,E=1,h=.66,[p,h,E,F,w,v,o,r,n,c,e,u]}class Re extends fe{constructor(t){super(),pe(this,t,Ie,Se,W,{})}}export{Re as default};
