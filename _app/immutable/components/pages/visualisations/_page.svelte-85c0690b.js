import{S as ie,i as ce,s as me,k as w,q as j,a as I,l as F,m as k,r as A,h as u,c as S,n as E,p as O,b as K,F as i,V as G,Y as he,C as Q,Z as fe,o as de,v as pe,e as Y,_ as ye,E as Z,f as C,d as _e,t as L,W as ge,x as J,y as X,$ as ee,z as te,A as ae,g as $e}from"../../../chunks/index-28406e41.js";import{_ as ve}from"../../../chunks/preload-helper-41c905a7.js";const ne=(t=0,n=1)=>Math.random()*(n-t)+t,le=(t,n,r)=>{const a=new Float32Array(r),h=(n-t)/(r-1);for(let c=0;c<r;c++)a[c]=t+h*c;return a},be=(t,n="scatter3d")=>{let r,a,h;return n==="scatter3d"&&(r=new Float32Array(t),a=new Float32Array(t),h=new Float32Array(t)),n==="heatmap"&&(r=le(-1,1,t),a=le(-1,1,t),h=new Array(t)),[r,a,h]},U=()=>Math.round(Math.random()*1e10).toString(36);function we(t){let n,r,a,h,c,f,_,x,g,d,$,p;return{c(){n=w("div"),r=w("div"),a=w("label"),h=j(`Resample
      `),c=w("input"),f=I(),_=w("button"),x=j("Regenerate"),g=I(),d=w("div"),this.h()},l(m){n=F(m,"DIV",{class:!0});var y=k(n);r=F(y,"DIV",{class:!0,style:!0});var v=k(r);a=F(v,"LABEL",{class:!0,for:!0});var l=k(a);h=A(l,`Resample
      `),c=F(l,"INPUT",{type:!0,id:!0}),l.forEach(u),f=S(v),_=F(v,"BUTTON",{class:!0});var R=k(_);x=A(R,"Regenerate"),R.forEach(u),v.forEach(u),g=S(y),d=F(y,"DIV",{id:!0,class:!0,style:!0}),k(d).forEach(u),y.forEach(u),this.h()},h(){E(c,"type","checkbox"),E(c,"id","resample-"+t[4]),E(a,"class","box svelte-1mf3lm7"),E(a,"for","resample-"+t[4]),E(_,"class","box svelte-1mf3lm7"),E(r,"class","w-100"),O(r,"padding","10px 0"),E(d,"id",t[3]),E(d,"class","w-100 fade-up h-100"),O(d,"height","400px"),E(n,"class","plut w-100 rx5 svelte-1mf3lm7")},m(m,y){K(m,n,y),i(n,r),i(r,a),i(a,h),i(a,c),c.checked=t[2],i(r,f),i(r,_),i(_,x),i(n,g),i(n,d),t[10](d),$||(p=[G(c,"change",t[9]),G(_,"click",function(){he(t[1])&&t[1].apply(this,arguments)})],$=!0)},p(m,[y]){t=m,y&4&&(c.checked=t[2])},i:Q,o:Q,d(m){m&&u(n),t[10](null),$=!1,fe(p)}}}function Fe(t,n,r){let a,h,c=!1;const f=U(),_=U();let{F:x=(e,s)=>e*s}=n,{samples:g=1e3}=n,{name:d="Function"}=n,{type:$="scatter3d"}=n,[p,m,y]=be(g,$);const v={heatmap:()=>{for(let e=0;e<g;e++)y[e]=new Float32Array(p.map(s=>x(s,m[e])))},scatter3d:()=>{for(let e=0;e<g;e++)p[e]=ne(-1,1),m[e]=ne(-1,1),y[e]=x(p[e],m[e])}};de(async()=>{const e=await ve(()=>import("../../../chunks/plotly-f659ad58.js").then(o=>o.p),[],import.meta.url);for(let o=0;o<g;o++)v[$]();let s={x:p,y:m,z:y,type:$,mode:"markers",marker:{size:Math.floor(16/Math.round(Math.log10(g))),color:y,colorscale:"Viridis",opacity:.75},hoverongaps:!1};e.newPlot(f,[s],{title:`${d} ${$}`.toUpperCase(),margin:{l:20,r:20,b:50,t:50}}),r(1,h=()=>{for(let o=0;o<g;o++)v[$]();e.redraw(f)})});function l(){c=this.checked,r(2,c)}function R(e){pe[e?"unshift":"push"](()=>{a=e,r(0,a)})}return t.$$set=e=>{"F"in e&&r(5,x=e.F),"samples"in e&&r(6,g=e.samples),"name"in e&&r(7,d=e.name),"type"in e&&r(8,$=e.type)},[a,h,c,f,_,x,g,d,$,l,R]}class re extends ie{constructor(n){super(),ce(this,n,Fe,we,me,{F:5,samples:6,name:7,type:8})}}function se(t,n,r){const a=t.slice();a[3]=n[r],a[7]=n,a[8]=r;const h=a[3].name;a[4]=h;const c=a[3].f;a[5]=c;const f=U();return a[6]=f,a}function oe(t){let n,r,a,h,c=t[3].title+"",f,_,x,g=t[3].desc+"",d,$,p,m,y,v,l,R,e,s,o,P,H,T,D,V;function ue(){t[2].call(l,t[8])}return s=new re({props:{samples:1e3,type:"scatter3d",name:t[4],F:new Function("x","y",`gamma=${+t[0][t[8]]}`,t[5])}}),P=new re({props:{samples:50,type:"heatmap",name:t[4],F:new Function("x","y",`gamma=${+t[0][t[8]]}`,t[5])}}),{c(){n=w("hr"),r=I(),a=w("section"),h=w("h2"),f=j(c),_=I(),x=w("div"),d=j(g),$=I(),p=w("div"),m=w("label"),y=j("Gamma"),v=I(),l=w("input"),R=I(),e=w("div"),J(s.$$.fragment),o=I(),J(P.$$.fragment),H=I(),this.h()},l(b){n=F(b,"HR",{class:!0}),r=S(b),a=F(b,"SECTION",{});var M=k(a);h=F(M,"H2",{});var N=k(h);f=A(N,c),N.forEach(u),_=S(M),x=F(M,"DIV",{});var q=k(x);d=A(q,g),q.forEach(u),$=S(M),p=F(M,"DIV",{});var B=k(p);m=F(B,"LABEL",{for:!0,style:!0});var W=k(m);y=A(W,"Gamma"),W.forEach(u),v=S(B),l=F(B,"INPUT",{name:!0,class:!0,type:!0}),R=S(B),e=F(B,"DIV",{class:!0});var z=k(e);X(s.$$.fragment,z),o=S(z),X(P.$$.fragment,z),z.forEach(u),B.forEach(u),H=S(M),M.forEach(u),this.h()},h(){E(n,"class","o-25"),E(m,"for","gamma-"+t[6]),O(m,"pointer-events","none"),E(l,"name","gamma-"+t[6]),E(l,"class","rpm-10 svelte-5sc4yz"),E(l,"type","text"),E(e,"class","Æ’")},m(b,M){K(b,n,M),K(b,r,M),K(b,a,M),i(a,h),i(h,f),i(a,_),i(a,x),i(x,d),i(a,$),i(a,p),i(p,m),i(m,y),i(p,v),i(p,l),ee(l,t[0][t[8]]),i(p,R),i(p,e),te(s,e,null),i(e,o),te(P,e,null),i(a,H),T=!0,D||(V=G(l,"input",ue),D=!0)},p(b,M){t=b,M&1&&l.value!==t[0][t[8]]&&ee(l,t[0][t[8]]);const N={};M&1&&(N.F=new Function("x","y",`gamma=${+t[0][t[8]]}`,t[5])),s.$set(N);const q={};M&1&&(q.F=new Function("x","y",`gamma=${+t[0][t[8]]}`,t[5])),P.$set(q)},i(b){T||(C(s.$$.fragment,b),C(P.$$.fragment,b),T=!0)},o(b){L(s.$$.fragment,b),L(P.$$.fragment,b),T=!1},d(b){b&&u(n),b&&u(r),b&&u(a),ae(s),ae(P),D=!1,V()}}}function xe(t){let n,r,a,h,c,f,_,x,g,d,$,p,m,y,v=t[1],l=[];for(let e=0;e<v.length;e+=1)l[e]=oe(se(t,v,e));const R=e=>L(l[e],1,1,()=>{l[e]=null});return{c(){n=w("script"),a=w("script"),c=I(),f=w("section"),_=w("h1"),x=j("Kernel Functions"),g=I(),d=w("div"),$=j(`The ultimate objective of a kernel is to use some fancy way to still tell us
    how similar any two inputs $x$, $x'$ are and map it to a higher dimensions.
    Some commonly used kernels are as follows. Our objective here is to define
    some basic kernels and then see how we can use them to combine them and
    generate fancier functions`),p=I();for(let e=0;e<l.length;e+=1)l[e].c();m=Y(),this.h()},l(e){const s=ye("svelte-1tfm19b",document.head);n=F(s,"SCRIPT",{src:!0});var o=k(n);o.forEach(u),a=F(s,"SCRIPT",{src:!0});var P=k(a);P.forEach(u),s.forEach(u),c=S(e),f=F(e,"SECTION",{});var H=k(f);_=F(H,"H1",{});var T=k(_);x=A(T,"Kernel Functions"),T.forEach(u),g=S(H),d=F(H,"DIV",{});var D=k(d);$=A(D,`The ultimate objective of a kernel is to use some fancy way to still tell us
    how similar any two inputs $x$, $x'$ are and map it to a higher dimensions.
    Some commonly used kernels are as follows. Our objective here is to define
    some basic kernels and then see how we can use them to combine them and
    generate fancier functions`),D.forEach(u),H.forEach(u),p=S(e);for(let V=0;V<l.length;V+=1)l[V].l(e);m=Y(),this.h()},h(){Z(n.src,r="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.5.1/math.js")||E(n,"src",r),Z(a.src,h="https://unpkg.com/bessel@1.0.2/bessel.js")||E(a,"src",h)},m(e,s){i(document.head,n),i(document.head,a),K(e,c,s),K(e,f,s),i(f,_),i(_,x),i(f,g),i(f,d),i(d,$),K(e,p,s);for(let o=0;o<l.length;o+=1)l[o].m(e,s);K(e,m,s),y=!0},p(e,[s]){if(s&3){v=e[1];let o;for(o=0;o<v.length;o+=1){const P=se(e,v,o);l[o]?(l[o].p(P,s),C(l[o],1)):(l[o]=oe(P),l[o].c(),C(l[o],1),l[o].m(m.parentNode,m))}for($e(),o=v.length;o<l.length;o+=1)R(o);_e()}},i(e){if(!y){for(let s=0;s<v.length;s+=1)C(l[s]);y=!0}},o(e){l=l.filter(Boolean);for(let s=0;s<l.length;s+=1)L(l[s]);y=!1},d(e){u(n),u(a),e&&u(c),e&&u(f),e&&u(p),ge(l,e),e&&u(m)}}}function Ee(t,n,r){let a;const h=[{name:"Plain",title:"Baseline testing with just to see things work",desc:`Here we plot the function $F(x, y) = x * y$ simply for an established
    baseline.`,f:"return x**2 * y**2;"},{name:"RBF",title:"RBF Kernel: $F(x, y) = e^{-\\gamma * (x - y)^2}$",desc:"Here we plot the function $F(x, y) = e^{-\\gamma * (x - y)^2}$, where $gamma$ is a hyperparameter.",f:"return Math.exp(-1 * gamma * (x - y) ** 2);"},{name:"Sigmoid",title:"Sigmoid Kernel: $F(x, y) = \\tanh(\\gamma * (x - y) + \\beta)$",desc:"Here we plot the function $F(x, y) = \\tanh(\\gamma * (x - y) + \\beta)$, where $\\gamma$ and $\\beta=0.5$ are hyperparameters.",f:"return Math.tanh(gamma * (x - y) + 0.5);"},{name:"Polynomial",title:"Polynomial Kernel: $F(x, y) = (\\gamma * (x - y) + \\beta)^d$",desc:"Here we plot the function $F(x, y) = (\\gamma * (x - y) + \\beta)^d$, where $\\gamma$, $\\beta=0.5$ and $d=2$ are hyperparameters.",f:"return (gamma * (x - y) + 0.5) ** 2;"},{name:"Matern",title:"Matern Kernel: $F(x, y) = \\frac{2^{1-\\nu}}{\\Gamma(\\nu)}\\left(\\sqrt{2\\nu}\\frac{|x - y|}{\\lambda}\\right)^\\nu K_\\nu\\left(\\sqrt{2\\nu}\\frac{|x - y|}{\\lambda}\\right)$",desc:"Here we plot the function $F(x, y) = \\frac{2^{1-\\nu}}{\\Gamma(\\nu)}\\left(\\sqrt{2\\nu}\\frac{|x - y|}{\\lambda}\\right)^\\nu K_\\nu\\left(\\sqrt{2\\nu}\\frac{|x - y|}{\\lambda}\\right)$, where $\\nu=1.5$ and $\\lambda=1$ are hyperparameters.",f:`{
        const nu = 2;
        return (
          (2 ** (1 - nu)) / math.gamma(nu) *
          ((2 * nu) ** 0.5 * Math.abs(x - y)) ** nu *
          BESSEL.besselk(nu, (2 * nu) ** 0.5 * Math.abs(x - y))
        );
      };`},{name:"Periodic or ESS",title:"Periodic Kernel: $F(x, y) = \\exp\\left(-\\frac{2\\sin^2\\left(\\pi\\frac{|x - y|}{p}\\right)}{l^2}\\right)$",desc:"Here we plot the function $F(x, y) = \\exp\\left(-\\frac{2\\sin^2\\left(\\pi\\frac{|x - y|}{p}\\right)}{l^2}\\right)$, where $l=1$ and $p=1$ are hyperparameters.",f:"return Math.exp(-2 * Math.sin(Math.PI * Math.abs(x - y)) ** 2);"},{name:"RQ",title:"RQ Kernel: $F(x, y) = \\left(1 + \\frac{|x - y|^2}{2\\alpha l^2}\\right)^{-\\alpha}$",desc:"Here we plot the function $F(x, y) = \\left(1 + \\frac{|x - y|^2}{2\\alpha l^2}\\right)^{-\\alpha}$, where $\\alpha=1$ and $l=1$ are hyperparameters.",f:"return (1 + (x - y) ** 2 / (2 * 1 * 1)) ** -1;"},{name:"White Noise",title:"White Noise Kernel: $F(x, y) = \\delta(x - y)$",desc:"Here we plot the function $F(x, y) = \\delta(x - y)$, where $delta$ is the Dirac delta function.",f:"return x === y ? 1 : 0;"}];function c(f){a[f]=this.value,r(0,a)}return r(0,a=["0.01","0.1","1","0.2","0.2","0.05","0.05"]),[a,h,c]}class Pe extends ie{constructor(n){super(),ce(this,n,Ee,xe,me,{})}}export{Pe as default};
